1. 
Что такое индексы?

Это структура данных, которая хранит в себе содержание столбца(ов) и ссылки на соответствующие этим столбцам строки.
Существуют кластеризованные и некластеризованные. 
Индексы можно сравнить с объездной дорогой - вместо того, чтобы ехать по длинному старому маршруту (полное сканирование таблицы),
база данных использует индекс, чтобы быстро объехать пробки и попасть прямо к нужным данным. 
Это сокращает время поиска и повышает скорость выполнения запросов.

Для чего они нужны?

Индексы нужны для оптимизации работы SQL-запросов. 
БД выбирает самый лучший вариант действий для исполнения запроса.
Изначально, когда ещё нет индексов внутри таблицы, база может сканировать только строки,
индексы же добавляют новый вариант исполнения для базы — позволяют
базе сканировать не полностью строки, а лишь элементы из определённого 
столбца(ов). Они используют под капотом двоичный поиск для обработки условий,
что в совокупности сильно ускоряет выполнение запроса. Из минусов — они занимают 
место, а также обновляются после таблиц при добавлении данных.

Кластеризованный индекс создаётся по умолчанию при объявлении первичного ключа (PRIMARY KEY) и определяет порядок строк.

Для создания некластеризованного индекса для неключевых столбцов используется запрос:
CREATE INDEX index_name ON table_name(column_name);
Или:
CREATE INDEX index_name ON table_name(column_name1, column_name2);

Их чаще всего применяют в больших таблицах, где редко обновляются/добавляются данные (ну либо хотя бы один столбец не меняется),
а также почти нет столбцов с NULL.

2.  
В чем разница между `INNER JOIN` и `LEFT JOIN`?  
INNER JOIN соединяет строки только при том условии, что столбец,  
по которому проводят JOIN, имеется в обеих таблицах, из-за этого он и INNER (внутренний). LEFT JOIN же делает приоритет на таблице  
слева (LEFT), то есть если в левой таблице есть строка с такой колонкой, а в правой нет, то он соединит и в правых колонках оставит NULL.  

Пример:

Таблица: users
id name 
1  Вася
2  Петя
3  Ваня

Таблица: items
id user_id title
1  1       Конфета
2  2       Кастрюля
3  1       Телефон

INNER JOIN например с таким запросом:  
SELECT  
    users.name,  
    items.title  
FROM users  
INNER JOIN items  
    ON users.id = items.user_id;  

Выведет такой результат:  
name title  
Вася Конфета  
Петя Кастрюля  
Вася Телефон  

LEFT JOIN с таким же запросом:  
SELECT  
    users.name,  
    items.title  
FROM users  
LEFT JOIN items  
    ON users.id = items.user_id;  

Выведет такой результат:
name title
Вася Конфета
Петя Кастрюля
Вася Телефон
Ваня NULL 

Выведет такой результат:  
name title  
Вася Конфета  
Петя Кастрюля  
Вася Телефон  
Ваня NULL  

У Вани NULL, так как нет строки в таблице items с его ключом.  
Порядок строк в обоих случаях случайный, если нет ORDER BY.  

3.  
Что такое транзакция?  
Это несколько запросов внутри одной обёртки. В случае провала одного из запросов обёртка откатывает (rollback) все которые были до  
проваленного.  
Свойства транзакций ACID:  
1. Транзакция всегда либо выполняется полностью, либо вообще не выполняется.  
2. Транзакция должна соблюдать все ограничения данных, типы, ключи, уникальность и т.д.  
3. Транзакции всегда изолированны, что помогает при одновременных запросах избежать состояние гонки.  
4. При сбоях транзакции никуда не теряются, либо отменятся, либо изменения всей транзакции сохранятся.  

Часто применяются в операциях с деньгами, документами и прочими важными данными за счёт своих свойств.

